# The Developer Bill of Rights

As seen in Extreme Programming:

- You have the right to know what is needed, via clear requirements, with clear declarations of priority
- You have the right to say how long each requirement will take you to implement, and to revise estimates given experience
- You have the right to accept your responsibilities instead of having them assigned to you
- You have the right to produce quality work at all times
- You have the right to peace, fun, and productive and enjoyable work

> A practice has to be an activity or a mode of working, but with a special twist: repeated application. In the absence of repetition, we may have an interesting technique, but it is not a practice unless it is performed regularly (in the case of an activity) or enforced systematically (in the case of a mode of working)
Bertrand Meyer in "Agile! The Good, the Hype and the Ugly"

> When there are two possible solutions, favor the one that is simpler and based on concrete need rather than the more intricate one that boasts of generality

Kevlin Henney in "97 Things Every Software Architect Should Know"

> "Big data" has this intoxicating effect. We start collecting it out of fear, but then it seduces us into thinking that it will give us power. In the end, it's just a mirror, reflecting whatever assumptions we approach it with. But collecting it drives this dynamic of relentless surveillance.

Maciej Cegłowski, "The Internet with a Human Face"

> Waste is anything that does not improve the quality of the product, does not reduce the amount of time and effort it takes to produce the product or does not provide real value to the customer

TJ Gokcen, "Kanban for developers"

> Any fool can write code that a computer can understand. Good programmers write code that humans can understand

Martin Fowler

> A common mistake that people make when trying to design something completely foolproof was to underestimate the ingenuity of complete fools

Douglas Adams (Mostly Harmless)

> If debugging is the process of removing bugs, then programming must be the process of putting them in

Dykstra

> Program designers have a tendency to think of the users as idiots who need to be controlled. They should rather think of their program as a servant, whose master, the user, should be able to control it.

John McCarthy

> A programming language is low level when its programs require attention to the irrelevant

Alan J. Perlis.

> Computer science education cannot make anybody an expert programmer any more than studying brushes and pigment can make somebody an expert painter

Eric S. Raymond

> For a long time it puzzled me how something so expensive, so leading edge, could be so useless. And then it occurred to me that a computer is a stupid machine with the ability to do incredibly smart things, while computer programmers are smart people with the ability to do incredibly stupid things. They are, in short, a perfect match

Bill Bryson

> Good design adds value faster than it adds cost

Thomas C. Gale

> Measuring programming progress by lines of code is like measuring aircraft building progress by weight

Bill Gates

> Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it

Brian W. Kernighan

> Talk is cheap. Show me the code

Linus Torvalds

> Most good programmers do programming not because they expect to get paid or get adulation by the public, but because it is fun to program

Linus Torvalds

> Given a large enough beta-tester and co-developer base, almost every problem will be characterized quickly and the fix will be obvious to someone.

Linus Torvalds

> I'm not a great programmer; I'm just a good programmer with great habits

Kent Beck

> Doing good engineering is not primarily making good decisions, it's seeking good feedback which lets you quickly discard bad decisions

Kent Beck

> The *craft* of programming begins with empathy, not formatting or languages or tools or algorithms or data structures

Kent Beck

> Don’t claim to have a config option, if you don’t actually have the UI to change it.

Linus Torvalds

> There are two ways of constructing a software design. One way is to make it so simple that there are obviously no deficiencies. And the other way is to make it so complicated that there are no obvious deficiencies

C.A.R. Hoare

> Another realization: choosing a tool is easy; adopting a tool is hard. One merely requires a decision; the other requires commitment.

Elisabeth Hendrickson (@testobsessed)

> The next important element in the concept of “beautiful code” is flexibility. I define flexibility here as freedom from enforcement from tools. When programmers are forced to do something against their intentions, for the tools’ sake, the result is stress. This stress negatively affects the programmer. The end result is far from happiness, and far from beauty as well, according to our definitions of beauty in code. Humans are more valuable than any tools or languages. Computers should serve programmers to maximize their productivity and happiness, but in reality, they often increase the burden instead of lightening it.

Yukihiro Matsumoto, "Treating Code As an Essay" (from "Beautiful Code")

> (...) a good engineer is not the one who knows how to build the most advanced system, but the one who knows when not to build that system.

Leon Fayer, "[Your code may be elegant](http://omniti.com/seeds/your-code-may-be-elegant)"

> We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.

Donald Knuth

> Understanding what is and isn't "premature" is what separates senior engineers from junior engineers.

Leon Fayer, "[Dissecting Today's Internet Traffic Spikes](http://omniti.com/seeds/dissecting-todays-internet-traffic-spikes)"

> Take a human desire, preferably one that has been around for a really long time…Identify that desire and use modern technology to take out steps

Ev Williams

> Metrics should be:
> - Actionable: For a report to be considered actionable, it must demonstrate clear cause and effect
> -Accessible: First of all, make the reports as simple as possible so that everyone understands them. And then share and display them!
> - Auditable: We must ensure that the data is credible to employees (and to investors, and friends, and whoever we show them too)

Eric Ries, "The Lean Startup" (bite-sized-summary of metrics chapter)

> "Three Strikes and Refactor"
> - Refactor When You Add Function
> - Refactor When You Need to Fix a Bug
> - Refactor As You Do a Code Review

Martin Fowler, "Refactoring: Improving the Design of Existing Code"

> (...) small methods really work only when you have good names, so you need to pay attention to naming. People sometimes ask me what length I look for in a method. To me length is not the issue. The key is the semantic distance between the method name and the method body. If extracting improves clarity, do it, even if the name is longer than the code you have extracted.

Martin Fowler, "Refactoring: Improving the Design of Existing Code"

> Projects usually start by listing out the team’s assumptions. However, they aren’t always labeled as "assumptions". Instead, they are often labeled as "requirements".

Jared Spool, "The Redesign of the Design Process" 

> Well, it seems to me the most successful programmers I've encountered don't craft software; they write software in order to move information around, in order to get something done. Information is the real deal - the software just defines the space that it moves around in. For those programmers, success is about getting information from point A where it's currentyly languishing to point B where it's going to actually be useful, as quickly and effectively as they can

Dan North

> A program should be light and agile,
> its subroutines connected like a string
> of pearls. The spirit of intent of the
> program should be retained throughout.
> There should be neither too little nor
> too much, neither needless loops nor
> useless variables, neither lack of struc-
> ture nor overwhelming rigidity.
>
> A program should follow the 'Law of
> Least AStonishment'. What is this law?
> It is simply that the program should
> always respond to the user in the way
> that astonishes him least.
>
> A program, no matter how complex,
> should act as a single unit. The program
> should be directed by the logic within
> rather than by outward appearances.
>
> If the program fails in these require-
> ments, it will be in a state of disorder
> and confusion. The only way to correct
> this is to rewrite the program.

Geoffrey James, "[The Tao of Programming](https://www.mit.edu/~xela/tao.html)"

> We are not here to write code... we are here to solve a problem to make someone’s life better. Code is the tool we use to build software to solve that problem.
> The corollary is that we'll keep needing "Solution Developers" (more than "Software Engineers") in the future. Part of the code itself might go away (with "No Code" tools), and Software might not be the right solution for a particular problem.
> People with strong critical thinking, communication skills, creativity, and ingenuity will be in high demand for a long while.

Mariano Simone, trying to philosophize and be profound 🤔
